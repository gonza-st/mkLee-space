- 객체지향에 대한 내용
- 어떻게 하면 유지보수가 좋은 코드를 설계할 수 있을까 ?
- 어떻게 하면 객체지향적으로 설계할 수 있을까 ?

참고 ) 저자의 문제가 너무 단정적으로 이야기한다

- 명확하게 표현해서 좋다는 의견도 있고 상반되는 주장에 대해서는 모두 틀렸다는 의미로 받아들일 수 있다

</br>
</br>

## Why 객체지향 ?

- 절차지향도 내용에 대해 이해하면 객체지향 보다 더 읽기 쉬운 경우도 있다
- 그러나 객체지향의 원칙을 잘 지키면 보다 좋은 점은 **“유지보수성”** 에 있다
- **이 책의 목표는 코드의 유지보수성 (maintainability) 을 향상시키는 것 입니다**

</br>
</br>

## 클래스

- 먼저 객체와 클래스와의 차이점을 이해해야 합니다
- **클래스는 객체의 팩토리 (factory) 입니다 !**
  - 일반적으로는 클래스가 객체를 인스턴스화한다 (instantiate) 라고 표현합니다
- 클래스를 바라보는 시각은
  - **필요할 때 객체를 꺼낼 수 있고, 더 이상 필요하지 않은 객체를 반환할 수 있는 객체의 웨어하우스 (warehouse) 로 클래스를 바라봤으면 좋겠습니다**
- 종종 클래스를 객체의 템플릿으로 설명하지만, 이 설명은 완전히 잘못되었습니다
  - 이런 류의 설명은 단순히 필요한 시점에 어딘가에서 복사되고 수동적인 코드 덩어리로 클래스를 바라봅니다
  - 비록 클래스가 기술적인 관점에서는 템플릿과 동일하더라도 이런 식으로 생각해서는 안됩니다
- **요점은 클래스는 객체의 능동적인 관리자 (active manager) 로서 생각해야 한다는 것 입니다**
- 사실 객체를 살아있는 생명체로 생각한다면 클래스는 객체의 어머니라고 할 수 있습니다

</br>
</br>

## 잘못된 클래스 이름

- 잘못된 방법은 클래스의 객체들이 무엇을 하고 있는지 (doing) 살펴본 후 기능 (function) 에 기반해서 이름을 짓는 방법입니다

```jsx
class CashFormatter {
		private int dollars;

		CashFormatter(int dollars) {
				this.dollars = dollars;
		}

		public String format() {
				return String.format("$ %d", this.dollars);
		}
}
```

- `CachFormatter` → 안에 `format()` 이라는 메서드 하나밖에 없지만 이는 단순히 `Cash` 라는 유기체의 기능 중에 하나일 뿐이다
- 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안됩니다 !
- **클래스의 이름은 무엇을 하는지 (what he does) 가 아니라 무엇인지 (what he is) 에 기반해야 합니다**
  - **클래스는 이것이 무엇인지에 기반해야 한다**
  - **객체는 그의 역량 (capability) 으로 특정지어야 하며 자신이 어떤 사람인지 키, 몸무게, 피부색 같은 속성 (attribute) 이 아닌 할 수 있는일 (what I can do) 로 설명해야 합니다**

```jsx
class Cash {
		private int dollars;

		Cash(int dollars) {
				this.dollars = dollars;
		}

		public String usd() {
				return String.format("$ %d", this.dollars);
		}
}
```

</br>
</br>

## -er

- 객체는 객체의 외부 세계와 내부 세계를 이어주는 연결 장치 가 아닙니다
- **객체는 내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합이 아닙니다**
- **대신 객체는 캡슐화된 데이터의 대표자 (representative) 입니다**
- 연결장치는 존중받지 못합니다
  - 정보를 수정하거나 스스로 어떤 일을 수행할 만큼 충분히 강력하지도 똑똑하지도 못하기 때문에 단순히 정보를 전달하기만 합니다
- 반면에 대표자는 스스로 결정을 내리고 행동할 수 있는 자립적인 엔티티입니다
- 클래스의 이름이 `-er` 로 끝난다면, 이 클래스의 인스턴스는 실제로는 객체가 아니라 어떤 데이터를 다루는 절차들의 집합일 뿐입니다
  - `-er` 은 단순히 어떤 데이터를 다루는 집합, 연결장치로서의 느낌이 난다
  - 캡슐화된 데이터들의 대표자라고 명시해야 한다 (ex. PrimeNumber, List)

</br>
</br>

## 객체는 → 무엇이다

- 객체는 프로시저의 집합처럼 행동해서는 안됩니다
  - 즉, 객체는 → 무엇을 한다 라고 표현하면 안된다
- 무언가 객체를 생성할 때는 외부에서 직접 객체 내부에 포함된 데이터를 처리하거나 조회하도록 허용해서는 안됩니다
- **대신 객체는 “지금은 내가 무엇이야 !” 라고 이야기해야 합니다**
- 외부에서 무언가를 처리해야 한다면 객체에게 그 일을 하도록 요청하고, 수신한 요청을 처리하기 위해 객체 스스로 무엇을 할지 결정해야 합니다
  - `PrimeNumber` 는 숫자의 리스트 입니다
  - 리스트를 처리하기 위한 메서드의 집합이 아닙니다 → 리스트 그 자체 입니다 (대표자)
- **새로운 클래스에 이름을 붙일 때는 무엇을 하는지 가 아닌 무엇인지 (what he is) 를 생각해야 한다는 것 입니다**
- Object IS A
  - 그는 SQL 레코드 이고 그 기능에는 데이터를 조회할 수 있는 기능이 있겠지
  - 그는 픽셀이고 그 기능에는 스스로 색을 바꿀 수 있겠지
  - 그는 하나의 파일이고 그 기능에는 디스크에서 내용을 읽어올 수 있겠지
  - 그는 HTML 이고 거기에는 여러가지 기능이 있겠지 그중에는 뭐 브라우저에 HTML 을 랜더링하는 기능 하나쯤은 있지 않겠어 ?
  - **내가 무엇을 하는지와 내가 누구인지는 다릅니다**

</br>
</br>

## 하나의 주 생성자 만 존재

- 이 내용에 따라 권장하는 방식으로 클래스를 설계한다면, **클래스는 많은 수의 `생성자` 와 적은 수의 메서드를 포함할 것 입니다**
  - `생성자` 수가 메서드의 수보다 더 많아 집니다
- 따라서 2 ~ 3 개의 메서드와 5 ~ 10 개의 `생성자` 를 포함하는 것이 적당합니다
  - 물론 이 값을 뒷받침할 만한 과학적인 근거는 없으며 단순 저자의 경험에 의해 정했다고 한다
- **여기에서 핵심은 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 `생성자` 가 존재한다는 점입니다**
- **사실 `생성자` 의 개수가 더 많을 수록 클래스는 더 개선되고, 사용자 입장에서 클래스를 더 편하게 사용할 수 있습니다**
  - 생성자가 더 많고 메서드는 2 ~ 3 개 뿐이니까 응집도 높은 객체가 설계될 것 이고, 그에 따라 단일 책임만 가지는 객체가 만들어질 것이다 !
  - 생각 자체를 생성자는 많지만 메서드는 2 ~ 3개만 있어야 한다고 생각하니까 그로 인해 간결한 설계가 파생되지 않을까 ? → 나의 생각

```java
new Cash(30);
new Cash("$29.95");
new Cash(29.95d);
new Cash(29.95f);
new Cash(29.95, "USD");
```

- 이 예시는 모두 동일한 객체를 생성합니다
  - 동일하다는 말은 생성된 객체들이 동일하게 행동한다는 뜻입니다
- **`생성자` 이 많아질수록 클라이언트가 클래스를 더 유연하게 사용할 수 있게 됩니다**
- 하지만 메서드가 많아질수록 클래스를 사용하기는 더 어려워집니다
  - 메서드가 많아지면 초점이 흐려지고, 단일 책임 원칙 (SRP) 을 위반하기 때문입니다
  - 이에 비해 `생성자` 가 많아지면 유연성이 향상됩니다
- **인자에 유연하다, 별도의 변환이나 파싱을 할 필요가 없기때문에 추가적인 유연성을 얻게된다**
  - Cash 클래스가 이런 작업들을 대신 처리해주고 있으니깐
  - 텍스트 형식의 값을 사용해야 하나요? → 여기 텍스트를 처리하는 `생성자` 가 있습니다
  - `double` 타입의 수를 전달해야 하나요? → 여기 `double` 타입의 인자를 받는 또 다른 `생성자` 가 있습니다

</br>
</br>

## 주 생성자의 유지보수성

- `생성자` 의 주된 작업은 제공된 인자를 사용해서 캡슐화하고 있는 프로퍼티를 초기화하는 일입니다
- 이런 초기화 로직을 단 하나의 `생성자` 에 위치시키고 “주(primary) 생성자” 이라고 부르기를 권장합니다
- 예제처럼 “부(secondary) 생성자” 는 주 `생성자` 을 호출하도록 만드세요

```java
class Cash {

		private int dollars;

		Cash(float dlr) {
				this((int) dlr);
		}

		Cash(String dlr) {
				this(Cash.parse(dlr));
		}

		Cash(int dlr) {
				this.dollars = dlr;
		}
}
```

- 이 예제처럼 주 `생성자` 을 모든 부 `생성자` 뒤에 위치시킨다 주된 이유는 유지보수성 때문이다 → 역자의 방식
  - 반년 전에 만들어 두었던 클래스에 정의된 10개의 `생성자` 들을 하나하나 읽어가면서 주 `생성자` 이 어떤 것인지 찾고 싶은 것이 아닌 마지막에 정의된 `생성자` 로 곧장 스크롤을 내렸을 때 그곳에 항상 주 `생성자` 이 있다면 유지보수하기 더 편합니다
- **하나의 주** `생성자` **와 다수의 부** `생성자` **원칙의 핵심은 무엇일까요 ?**
  - **이 원칙이 중복 코드를 방지하고 설계를 더 간결하게 만들기 때문에 유지보수성이 향상된다는 점입니다**

</br>
</br>

## 생성자의 인자에 손대지 말라

- 진정한 객체지향에서 인스턴스화 (instantiation) 란 더 작은 객체들을 조합해서 (compose) 더 큰 객체를 만드는 것을 의미합니다
- 객체들을 조합해야 하는 단 하나의 이유는 새로운 계약을 준수하는 새로운 엔티티(entity) 가 필요하기 때문입니다
- 잘못된 방법

```java
class	Cash	{
		private int dollars;

		Cash(String dlr) {
				this.dollars = Integer.parseInt(dlr);
		}
}
```

- 올바른 방법 → 새로운 계약이 만들어짐에 따라 작은 객체들의 조합을 만들어서 처리해야 한다

```java
class Cash {
		private Number dollars;

		Cash(String dlr) {
				this.dollars = new StringAsInteger(dlr);
		}
}

class StringAsInteger implements Number {
		private String source;

		StringAsInteger(String src) {
				this.source = src;
		}

		int intValue() {
				return Integer.parseInt(this.source);
		}
}
```

</br>
</br>

## 객체는 상태에 의해 식별해야 한다

```java
class Cash {
		private Integer digits;

		private Integer cents;

		private String currency;
}
```

- `Cash` 클래스는 3개의 객체를 캡슐화하고 있습니다
- 이 3개의 객체들이 함께 모여 `Cash` 클래스의 객체를 식별합니다
- **다시 말해 동일한 값의 달러, 센트, 통화를 캡슐화하는 `Cash` 클래스의 두 객체는 서로 동일해야 합니다**
  - Java 언어의 관점에서 보자면 기술적으로 올바른 설명은 아니지만 이는 이전 컴퓨터에 의존적인 설계적 결함이라고 생각합니다
  - **개인적으로 (저자) 객체 패러다임은 순수한 객체지향 언어를 이용해서 상태가 동일하면 동일한 객체로서 바라봐야 한다고 생각합니다**
- 또한 “객체” 는 고수준의 행위를 발행하기 까지는 객체들의 집합체가 이루어져야 합니다
  - **즉, 고수준의 행위는 객체들의 집합체(aggregation) 에 의해 발행됩니다**
  - 예시로서
    - 책은 페이지, 표지, ISBN 의 집합체이고
    - 책장은 책과 제목의 집합체
    - 자동차는 바퀴, 엔진, 유리 의 집합체
    - 차고는 자동차와 주소의 집합체
  - **다른 객체를 캡슐화하지 않는 객체란 존재하지도 않으며 존재할 수도 없다는 사실을 보여줍니다**
  - **부품이 없는 객체는 의미가 없기 때문입니다**
- 상태 없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 합니다

</br>
</br>

## 캡슐화는 최대 4개 까지

- 왜 4 일까요 ?
- 객체의 식별자는 기본적으로 세계 안에서 객체가 위치하는 좌표입니다
- 나의 자동차는 제조사, 모델, 제조년도 라는 특성으로 구성되어 있습니다
  - 이 세가지 특성을 사용하면 이 세계 안에서 제 자동차를 식별할 수 있습니다
- 요점은 4개 이상의 좌표는 직관에 위배된다는 사실입니다
- **세계 안의 객체를 바라보는 우리의 사고방식으로 4개 이상의 요소로 구성된 좌표를 이해하는 것은 너무나도 어렵습니다**
- 반례
  - 자신과 이웃이 동일한 제조사, 모델, 제조년도의 자동차를 가지고 있지만 두 자동차는 여전히 다른 자동차가 아니냐 ?
- 반례의 내용은 맞는 말 입니다.
- 하지만 이것은 단순히 실세계 자동차가 객체지향 세계의 자동차 보다 더 복잡하기 때문입니다
- 물론 객체가 자동차를 참조한다고 한다면,
- **속성의 그룹화를 통해 결과적으로 전체 속성들은 객체들로 구성된 트리(tree) 를 구성하게 됩니다**
- 예를 들어
  - 자동차 객체는 타입과 차량인식번호 (VIN)
  - 타입은 제조사, 모델, 제조년도 로 캡슐화 할 수 있습니다
  - 결과적으로 자동차 객체는 3개의 작은 객체를 포함하게 됩니다
  - 최댓값은 4입니다. 더 많은 객체가 필요하다면 클래스를 더 작은 클래스들로 분해해야 합니다
  - 그리고 Java 의 결합을 해결하기 위해 `==` 연산자를 사용하지 말고 항상 `equals()` 메서드를 오버라이드하기 바랍니다

</br>
</br>

# 메서드 이름을 잘 지으세요 !

## 저자의 제안

- 저자의 경험에 의해 빌더(builder) 의 이름은 명사 로 조정자(manipulator) 의 이름은 동사로 짓는 것이 좋다

</br>
</br>

## 빌더

- **빌더(builder) 란 뭔가를 만들고 새로운 객체를 반환하는 메서드를 가리킵니다**
- 빌더는 항상 뭔가를 반환합니다
- 절대 void 가 될 수 없으며, 이름은 항상 명사여야 합니다

```java
int pow(int base, int power);
float speed();
Employee employee(int id);
String parsedCell(int x, int y);
```

- `parsedCell` 같은 경우는 명사를 꾸여주는 형용사가 들어가 있는 형태인데 단지 형용사를 덧붙여 메서드의 이름을 좀 더 풍부하게 설명하고 있을 뿐 원칙에 위배된 것이 아니다

</br>
</br>

## 조정자

- **객체로 추상화한 실세계 엔티티를 수정하는 메서드를 조정자(manipulator) 라고 부른다**
- 조정자의 반환 타입은 항상 void 이고, 이름은 항상 동사이다

```java
void save(String content);
void put(String key, Float value);
void remove(Employee emp);
void quicklyPrint(int id);
```

- `quicklyPrint` 는 부사를 통해 동사를 꾸미는 형태로 지어졌습니다
- 여기에 중심이 되는 것은 `print` 라는 동사입니다
- 그에 비해 부사인 `quickly` 는 단지 메서드의 문맥과 목적에 관한 풍부한 정보를 제공하기 위해 존재할 뿐 입니다

</br>
</br>

## 잘못된 예시

- 빌더는 어떤 것을 만들고, 조정자는 뭔가를 조작한다
- 뭔가를 조작한 후 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다

```java
// 저장된 전체 바이트를 반환
int save(String content);
// map이 변경된 경우 true를 반환
boolean put(String key, Float value);
// speed를 저장한 후 이전 값을 반환
float speed(float val);
```

- 문제를 해결할 수 있는 유일한 방법은 아무것도 반환하지 않는 빌더 형식의 메서드로 수정하는 것 뿐 입니다
- 추가로 `getter` 는 `get` 이라는 단어는 동사이지만, `getter` 는 근본적으로 어떤 값을 반환하는 빌더입니다
  - 이것이 `getter` 를 반대하는 첫번째 이유입니다

</br>
</br>

## 빌더는 명사이다

- 일반적인 예시를 생각해봅시다, 제과점에 들러 “브라우니를 요리해 주세요” 라거나 “커피 한잔 끓여 주세요” 라고 말하지 않습니다
- 대신에 “브라우저 주세요”, “커피 한잔 주세요” 라고 말합니다
- 브라우저를 요리하거나 커피를 끓이는 정확한 방법은 제 관심사가 아닙니다 → 제과점이 신경써야 할 일 입니다

```java
class Bakery {
		Food cookBrownie();
		Drink brewCupOfCoffee(String flavor);
}
```

- 두 메서드는 실제로 객체의 메서드라고 생각하지 않습니다 이들은 프로시저(procedure) 입니다
- 두 메서드의 이름은 `Bakery` 를 자립적이고 자율적인 객체로 존중하지 않고 객체에게 할 일을 일일이 명령해야 한다고 속삭입니다
- 그저 두 개의 기계적인 명령어를 호출하고 있을 뿐 입니다
- 올바르게 지은 메서드 이름은 사용자들이 객체를 설계한 목적, 객체가 수행해야 하는 임무, 객체의 존재 목적과 살아가는 의미를 더 잘 이해할 수 있도록 해줍니다
  - 부적절하게 지은 메서드 이름은 객체의 전체적인 개념을 망가트리고 사용자들이 객체를 데이터 집합이나 프로시저들의 모음으로 다루도록 종용합니다
- 객체는 단순히 지시에 따르는 것이 아니라 계약에 기반해 일하고 싶어합니다
- 이런 이유로 메서드의 이름을 동사로 지을 때에는 객체에게 “무엇을 할지(what to do)” 를 알려주어야 합니다
- 무엇을 만들어야 하는지만 요청하고 만드는 방법은 객체 스스로 결정하도록 해야 합니다

```java
int add(int x, int y); -> int sum(int x, int y);
```

- 이런 변화가 사소하고 하찮게 보일 지도 모르겠지만 실제로는 사고하는 방식에 있어 큰 차이를 만듭니다
- 우리는 객체에게 x 와 y 를 더하라고(add) 요청하지 않습니다
- 대신, 두 수의 합(sum) 을 계산하고 새로운 객체를 반환해 달라고 요청합니다
- 객체가 정말로 합계를 알아낼까요? 저는 모릅니다, 그저 알아낼 수 있으리라고 추측할 뿐 입니다 → 제가 아는 것은 결과가 x 와 y 를 더한 값과 같다는 사실뿐입니다

</br>
</br>

## 조정자는 동사다

- 객체는 실세계의 엔티티(entity) 를 대표합니다
- `File` 클래스의 객체는 디스크에 저장된 파일을 표현하고
- `Pixel` 클래스의 객체는 스크린에 표시된 픽셀을 표현한다

```java
class Pixel {
		void paint(Color color);
}

Pixel center = new Pixel(50, 50);
center.paint(new Color("red");
```

- 이 코드는 `center` 객체에게 스크린 상의 (50, 50) 좌표에 위치한 픽셀을 칠하도록 요청합니다
- 이 과정에서 뭔가가 만들어질(build) 것이라고 기대하지 않습니다
- `paint` 메서드는 값을 반환하지 않습니다, 제과점을 설명하면서 사용했던 은유를 동일하게 사용해 보자면 마치 바텐데에게 음악을 틀어 달라고 요청하는 것과 같습니다
- 바텐더가 볼륨을 높일까요? 그럴 수도 있고, 아닐 수도 있습니다 혹은 우리의 요청이 무시될 지도 모릅니다
- 그렇더라도 처음부터 뭔가를 돌려받을 것이라고 기대하지 않았기 때문에 절대 무례한 일이 아닙니다
- 여러분이 바텐더에게 “음악을 틀고 현재의 볼륨 상태를 말해주세요” 라고 말한다면 이것은 값을 반환하는 조정자의 모습을 정확하게 표현한 것이며 매우 무례한 행동입니다
  - 따라서 다른 점은 반환값의 유무에 있습니다, 오직 빌더만이 값을 반환할 수 있고 이름은 명사입니다
  - 객체가 뭔가를 조정해야 한다면 이름은 동사이고 반환값이 없습니다

</br>
</br>

## 빌더와 조정자 혼합하기

- 파일 내용을 저장하고 저장된 바이트 수를 반환하는 메서드가 있다고 가정해보겠습니다

```java
class Document {
		int write(InputStream content);
}
```

- 이 메서드는 얼핏 보면 문제가 없어 보이지만 사실 앞에서 설명한 원칙에 위반하고 있습니다
  - 원칙상으로는 메서드 `write` 의 반환 타입을 `void` 로 바꿔야 하지만, 우리는 실제로 저장된 바이트 수를 알 필요가 있습니다
- `write()` 메서드는 데이터를 쓰는 동시에, 쓰여진 바이트 수를 카운트합니다 → 다시 말해서 하나의 메서드 안에서 너무 복잡한 일을 처리하고 있습니다
- 메서드의 목적이 명확하지 않기 때문에 깔끔하게 명사나 동사 둘 중 하나로 이름을 지을 수가 없습니다
- 초점이 뚜렷하지 않다는 이야기입니다.

```java
class Document {
		OutputPipe output();
}

class OutputPipe {
		void write(InputStream content);
		int bytes();
		long time();
}
```

- 코드에서 보는 것처럼 `output()` 메서드는 빌더입니다 → 이 메서드는 문서에 내용을 쓸 준비를 하는 `OutputPipe` 타입의 객체를 생성합니다
  - 이 객체의 이름을 `writer` 로 짓지 않았습니다
- 내용은 아직 쓰여지지 않았습니다 단지, 연산을 수행할 객체를 준비한 것뿐입니다
- 그리고나서 `OutputPipe` 인스턴스에 `write()` 를 호출하면 객체는 관련된 데이터를 모으기 시작합니다
- `OutputPipe` 객체를 이용해서 바이트 수(`bytes()` 빌더) 와 처리 시간 (`time()` 빌더) 과 같은 더 다양한 정보를 수집할 수도 있습니다

</br>
</br>

## Boolean 값을 결과로 반환하는 경우

- 기존에 `isEmpty()` 혹은 `equals()` 혹은 `exists()` 메서드가 존재합니다
- Boolean 값을 반환하는 메서드는 규칙에 있어서 예외적인 경우 입니다
  - 값을 반환하기 때문에 이 메서드들은 빌더에 속하지만, 가독성 측면에서 이름은 “형용사” 로 지어야 합니다

```java
boolean readable();
boolean negative();
boolean empty();
```

- 접두사 `is` 는 중복이기 때문에 메서드의 이름에는 포함시키지 않았지만, 메서드를 읽을 때는 일시적으로 앞에 붙여 자연스럽게 들리도록 해야 합니다
- 다시 말해서 메서드를 읽을때는 접두사 `is` 를 추가해야 하고, 실제 코드에서는 빼야 한다는 뜻 입니다
  - 형용사 대신 동사를 사용하는 실수를 막으려면 이와 같은 훈련이 요구됩니다

```java
boolean readable(); -> is readable
boolean negative(); -> is negative
boolean empty(); -> is empty
```

- Java 를 포함한 대부분의 언어들의 논리 구성자에서는 `==` 부분을 생략합니다

```java
if (name.empty()) {
		// 뭔가를 한다
}
```

- 따라서 메서드의 이름을 형용사로 지어야 더 자연스럽게 읽히는 문장이 됩니다
